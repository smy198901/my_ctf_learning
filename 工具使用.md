本文用于记录网络安全工具的使用方法。

# sqlmap

```shell
#获取数据库
python sqlmap.py -u URL --dbs --batch 
#获取当前数据库
python sqlmap.py -u URL --current-db --batch
#获取数据库中的表
python sqlmap.py -u URL -D dbname --tables --batch
#获取表的字段
python sqlmap.py -u URL -D dbname -T tablename --columns --batch
#获取字段的值
python sqlmap.py -u URL -D dbname -T tablename -C "password,username" --dump --batch
```

## POST注入

1. 打开burp抓包，右键，copy to file (1.txt)

2. 使用sqlmap

   ```shell
   python -r 1.txt --dbs
   ```

# 隐写工具

## Steghide

Steghide是一个可以将文件隐藏到图片或音频中的工具。

### 隐藏文件

steghide embed -cf [图片文件载体] -ef [待隐藏文件]

```powershell
steghide embed -cf 1.jpg -ef 1.txt
```

提示输入密码(提取文件用到)，不输入则为空密码。

### 查看图片中嵌入的文件信息

steghide info [图片文件载体]

```powershell
steghide info 1.jpg
```

### 提取隐藏文件

steghide extract -sf [图片文件载体]

```powershell
steghide extract -sf 1.jpg
```

## tcpxtract

安装在Kali下。

## pcapfix(PCAP文件修复工具)

pcapfix是一种修复损坏pcap文件的工具。它会检查一个完整的pcap全局头。如果有任何损坏字节就会修复它。如果缺少一个字节,它会创建和补充一个新的字节到文件的开头，然后试图找到pcap包头、检查和修复它。

安装在Kali下。

## convert(图片操作，gif分离合并)

工具按照在CTF虚拟机中，我的kali中没安装成功。

1. 把gif图片按帧分离

   ```shell
   convert +adjoin glance.gif piece_%02d.gif
   ```

2. 把图片从左到右拼接成一个图片

   ```shell
   convert +append piece*.gif final.png
   ```

3. 更改文件类型

   ```shell
   convert input.jpg output.png
   ```

4. 旋转图片

   ```shell
   convert -rotate 90 input.jpg output.jpg
   ```

5. 

# MISC（杂项）

## extundelete（数据恢复）

Linux镜像数据恢复。

> 其中，参数（options）有：
> --version, -[vV]，显示软件版本号。
> --help，显示软件帮助信息。
> --superblock，显示超级块信息。
> --journal，显示日志信息。
> --after dtime，时间参数，表示在某段时间之后被删的文件或目录。
> --before dtime，时间参数，表示在某段时间之前被删的文件或目录。
>
> 动作（action）有：
> --inode ino，显示节点“ino”的信息。
> --block blk，显示数据块“blk”的信息。
> --restore-inode ino[,ino,...]，恢复命令参数，表示恢复节点“ino”的文件，恢复的文件会自动放在当前目录下的RESTORED_FILES文件夹中，使用节点编号作为扩展名。
> --restore-file 'path'，恢复命令参数，表示将恢复指定路径的文件，并把恢复的文件放在当前目录下的RECOVERED_FILES目录中。
> --restore-files 'path'，恢复命令参数，表示将恢复在路径中已列出的所有文件。
> --restore-all，恢复命令参数，表示将尝试恢复所有目录和文件。
> -j journal，表示从已经命名的文件中读取扩展日志。
> -b blocknumber，表示使用之前备份的超级块来打开文件系统，一般用于查看现有超级块是不是当前所要的文件。
> -B blocksize，通过指定数据块大小来打开文件系统，一般用于查看已经知道大小的文件。

## Stegsolve

>1.File Format:这里你会看见图片的具体信息有时候有些图片隐写的flag会藏在这里
>
>2.Data Extract:数据提取
>
>RGB是红绿蓝 但他们的值代表的实际上是亮度
>
>R的数字越大，则代表红色亮度越高；R的数字越小，则代表红色亮度越低。G，B同理
>
>R的亮度各有256个级别，GB同理。即从0到255，合计为256个。从数字0到255的逐渐增高，我们人眼观察到的就是亮度越来越大，红色、绿色或蓝色越来越亮。然而256是2的8次方 所以你会看见上图的7~0 一共8个通道
>
>而Alpha就是透明度 该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域
>
>alpha的值为0就是全透明，alpha 的值为 255 则表示不透明
>
>因此左半部分就理解了
>
>右半部分就是Extra By(额外的)和Bit Order（位顺序）和Bit Plane Order（位平面的顺序）
>
>1）.Extra By(额外的)：分为row（行）和column（纵）
>
>  每个像素用R，G，B三个分量表示，那么一张图片就像一个矩阵，矩阵的每个单位就是（0~255，0~255，0~255）
>
>  也就会有是纵排列和行排列了，一般事先访问行再访问列（如果相反会引起ve使用方法）
>
>￼2）.Bit Order（位顺序）:MSB是一串数据的最高位，LSB是一串数据的最低位。
>
>3）.Bit Plane Order（位平面的顺序)
>
>   整个图像分解为8个位平面，从LSB(最低有效位0)到MSB（最高有效位7）随着从位平面0 到位平面7，位平面图像的特征逐渐变得复杂，细节不断增加。（一般我们的图片如果是RGB那么就是24位 3乘8嘛）
>
>4）Bit Plane Order（位平面的顺序）:一般图片是24位 也就是3个8 大家可以想像成三明治 比如BGR就是B为三明治第一层 G为第二层 R为第三层。
>
>3.Steregram Solve:立体试图 可以左右控制偏移 可以放张图片试一下就知道这个是什么意思了
>
>4.Frame Browser:帧浏览器  主要是对GIF之类的动图进行分解，把动图一帧帧的放，有时候会是二维码
>
>5.Image Combiner:拼图，图片拼接（意思显而易见）
>

# PWN

## pwntools

官网的一个简单样例

```
from pwn import *
context(arch = 'i386', os = 'linux')

r = remote('exploitme.example.com', 31337)
# EXPLOIT CODE GOES HERE
r.send(asm(shellcraft.sh()))
r.interactive()
```

```
from pwn import *     ##用来导入pwntools模块
```

```
context(arch = 'i386', os = 'linux') ##设置目标机的信息
```

```
r = remote('exploitme.example.com', 31337) #用来建立一个远程连接，url或者ip作为地址，然后指明端口
```

这里也可以仅仅使用本地文件,调试时方便:

```
r = process("./test") #test即为文件名,这使得改变远程和本地十分方便.
```

```
asm(shellcraft.sh()) #asm()函数接收一个字符串作为参数，得到汇编码的机器代码。
```

比如

```
>>> asm('mov eax, 0')
'\xb8\x00\x00\x00\x00'
```

shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。

其中的子模块声明架构，比如shellcraft.arm 是ARM架构的，shellcraft.amd64是AMD64架构，shellcraft.i386是Intel 80386架构的，以及有一个shellcraft.common是所有架构通用的。

而这里的shellcraft.sh()则是执行/bin/sh的shellcode了

r.send()将shellcode发送到远程连接

最后，

```
r.interactive()  #将控制权交给用户，这样就可以使用打开的shell了
```

Context设置

`context`是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。

一般来说我们设置context只需要简单的一句话:

```
context(os='linux', arch='amd64', log_level='debug')
```

``这句话的意思是：

\1. os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux
\2. arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’
\3. log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。

数据打包

数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便

用法:
\* `p32/p64`: 打包一个整数,分别打包为32或64位
\* `u32/u64`: 解包一个字符串,得到整数

p对应pack,打包,u对应unpack,解包,简单好记

```
payload = p32(0xdeadbeef) # pack 32 bits number
```

数据输出

如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法:

```
some_str = "hello, world"
log.info(some_str)
```

``其中的info代表是log等级，也可以使用其他log等级。

Cyclic Pattern

Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。

在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。
用法：

```
cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串
cyclic_find(0x61616161) # 找到该数据在pattern中的位置
cyclic_find('aaaa') # 查找位置也可以使用字符串去定位
```

``比如，我们在栈溢出的时候，首先构造`cyclic(0x100)`，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过`cyclic_find(0x61616161)`就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。

汇编与shellcode

有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。
首先，常用的，也是最简单的shellcode，即调用`/bin/sh`可以通过shellcraft得到：

注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。

```
print(shellcraft.sh()) # 打印出shellcode
```

``不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编

```
print(asm(shellcraft.sh())) # 打印出汇编后的shellcode
```

``asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用`keystone-engine`项目，这里就不再赘述了。

asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。
