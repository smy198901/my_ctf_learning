# Base家族

Base家族有：Base16、Base32、Base36、Base58、Base62、Base64、Base64Url、Base85、Ascii85、Base91、Base92

使用Python脚本：BaseCrack ，具体用法可以查看脚本的Readme。

# Rabbit

```
密文：U2FsdGVkX19mGsGlfI3nciNVpWZZRqZO2PYjJ1ZQuRqoiknyHSWeQv8ol0uRZP94
MqeD2xz+
密钥：Rabbit
```

工具使用`AES_DES_Rabbit_RC4_TripleDes`文件夹中的网页。

# OoK

```
Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook.
```

使用ook.py 解密。

```
python ook.py -0 file_name
```

# BrainFuck

类似于下面这种类型：

```
+++++ +++++ [->++ +++++ +++<] >++.+ +++++ .<+++ [->-- -<]>- -.+++ +++.<
++++[ ->+++ +<]>+ +++.< +++++ +++[- >---- ----< ]>--. .--.- -.-.- --.-.
+++++ +..-- -..<+ +++++ +[->+ +++++ +<]>+ +.<++ ++++[ ->--- ---<] >----
----- .---- -.<++ ++++[ ->+++ +++<] >++++ +++++ +++.< +++++ ++[-> -----
--<]> .++.- ----. <++++ +++[- >++++ +++<] >+++. --.<+ +++++ [->-- ----<
]>--- ----- ---.+ .<+++ +++[- >++++ ++<]> +++++ +++++ ++.<+ +++++ [->--
----< ]>--- ----- ---.- .++++ .<+++ +++[- >++++ ++<]> +++++ +++.< +++++
+[->- ----- <]>-- ----- ---.- ----- .++++ +++++ .---- ----. <++++ ++[->
+++++ +<]>+ +++++ +++++ +.<++ +++[- >++++ +<]>+ ++.<
```

解密：

```python
python ook.py -b file_name
```

# 培根密码

培根密码，类似于二进制0和1，但是是用A和B来替代的。

解码工具: CtfCrackTool。

密码表如下：

|      |       |      |       |      |       |      |       |
| ---- | ----- | ---- | ----- | ---- | ----- | ---- | ----- |
| A/a  | aaaaa | H/h  | aabbb | O/o  | abbba | V/v  | babab |
| B/b  | aaaab | I/i  | abaaa | P/p  | abbbb | W/w  | babba |
| C/c  | aaaba | J/j  | abaab | Q/q  | baaaa | X/x  | babbb |
| D/d  | aaabb | K/k  | ababa | R/r  | baaab | Y/y  | bbaaa |
| E/e  | aabaa | L/l  | ababb | S/s  | baaba | Z/z  | bbaab |
| F/f  | aabab | M/m  | abbaa | T/t  | baabb |      |       |
| G/g  | aabba | N/n  | abbab | U/u  | babaa |      |       |

# Quoted-printable

**Quoted-printable**可译为“可打印字符引用编码”，编码常用在电子邮件中，如：Content-Transfer-Encoding: quoted-printable ，它是MIME编码常见一种表示方法！ 在邮件里面我们常需要用可打印的ASCII字符 (如字母、数字与"=")表示各种编码格式下的字符！Quoted-printable将任何8-bit字节值可编码为3个字符：一个等号"="后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。例如，ASCII码换页符（十进制值为12）可以表示为"=0C"， 等号"="（十进制值为61）必须表示为"=3D"，gb2312下“中”表示为=D6=D0。除了可打印ASCII字符与换行符以外，所有字符必须表示为这种格式。因为Quoted-printable编码简单、方便因此在电子邮件中应用广泛！

```
=E7=94=A8=E4=BD=A0=E9=82=A3=E7=81=AB=E7=83=AD=E7=9A=84=E5=98=B4=E5=94=87=E8=AE=A9=E6=88=91=E5=9C=A8=E5=8D=88=E5=A4=9C=E9=87=8C=E6=97=A0=E5=B0=BD=E7=9A=84=E9=94=80=E9=AD=82
```

python脚本如下：

```python
import quopri

a = '=E7=94=A8=E4=BD=A0=E9=82=A3=E7=81=AB=E7=83=AD=E7=9A=84=E5=98=B4=E5=94=87=E8=AE=A9=E6=88=91=E5=9C=A8=E5=8D=88=E5=A4=9C=E9=87=8C=E6=97=A0=E5=B0=BD=E7=9A=84=E9=94=80=E9=AD=82'
b= '用你那火热的嘴唇让我在午夜里无尽的销魂'
print(quopri.decodestring(a).decode('utf-8'))
print(quopri.encodestring(b.encode('utf-8')))
```

# 埃特巴什码（Atbash Cipher）

埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，其原理为：它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：
明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
下面给出一个例子：
明文：the quick brown fox jumps over the lazy dog
密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt

python脚本：`Atbash Cipher.py`

# 当铺密码

当铺密码就是一种将中文和数字进行转化的密码，算法相当简单:当前汉字有多少笔画出头，就是转化成数字几。例如：
王：该字外面有 6 个出头的位置，所以该汉字对应的数字就是 6；
口：该字外面没有出头的位置，那就是0；
人：该字外面有 3 个出头的位置，所以该汉字对应的数字就是 3；

```
密文：王夫 井工 夫口 由中人 井中 夫夫 由中大
对应：67 84 70 123 82 77 125
翻译成 ASCII码： CTF{RM}
```

也可能是数字对应中文的笔画数。

# 元素周期表

flag对应  9 57 64

| 原子序数 | 符号 | 原子序数 | 符号 |
| -------- | :--- | -------- | ---- |
| 1        | H    | 60   | Nd   |
| 2        | He   | 61   | Pm   |
| 3        | Li   | 62   | Sm   |
| 4        | Be   | 63   | Eu   |
| 5        | B    | 64   | Gd   |
| 6        | C    | 65   | Tb   |
| 7        | N    | 66   | Dy   |
| 8        | O    | 67   | Ho   |
| 9        | F    | 68   | Er   |
| 10       | Ne   | 69   | Tm   |
| 11       | Na   | 70   | Yb   | 
| 12       | Mg   | 71   | Lu   | 
| 13       | Al   | 72   | Hf   | 
| 14       | Si   | 73   | Ta   | 
| 15       | P    | 74   | W    | 
| 16       | S    | 75   | Re   | 
| 17       | Cl   | 76   | Os   | 
| 18       | Ar   | 77   | Ir   | 
| 19       | K    | 78   | Pt   | 
| 20       | Ca   | 79   | Au   | 
| 21       | Sc   | 80   | Hg   | 
| 22       | Ti   | 81   | Tl   | 
| 23       | V    | 82   | Pb   | 
| 24       | Cr   | 83   | Bi   | 
| 25       | Mn   | 84   | Po   | 
| 26       | Fe   | 85   | At   | 
| 27       | Co   | 86   | Rn   | 
| 28       | Ni   | 87   | Fr   | 
| 29       | Cu   | 88   | Ra   | 
| 30       | Zn   | 89   | Ac   | 
| 31       | Ga   | 90   | Th   | 
| 32       | Ge   | 91   | Pa   | 
| 33       | As   | 92   | U    | 
| 34       | Se   | 93   | Np   | 
| 35       | Br   | 94   | Pu   | 
| 36       | Kr   | 95   | Am   | 
| 37       | Rb   | 96   | Cm   | 
| 38       | Sr   | 97   | Bk   | 
| 39       | Y    | 98   | Cf   | 
| 40       | Zr   | 99   | Es   | 
| 41       | Nb   | 100  | Fm   | 
| 42       | Mo   | 101  | Md   | 
| 43       | Tc   | 102  | No   | 
| 44       | Ru   | 103  | Lr   | 
| 45       | Rh   | 104  | Rf   |
| 46       | Pd   | 105  | Db   |
| 47       | Ag   | 106  | Sg   |
| 48       | Cd   | 107  | Bh   |
| 49       | In   | 108  | Hs   |
| 50       | Sn   | 109  | Mt   |
| 51       | Sb   | 110  | Ds   |
| 52       | Te   | 111  | Rg   |
| 53       | I    | 112  | Cn   |
| 54       | Xe   | 113  | Nh   |
| 55       | Cs   | 114  | Fl   |
| 56       | Ba   | 115  | Mc   |
| 57       | La   | 116  | Lv   |
| 58       | Ce   | 117  | Ts   |
| 59       | Pr   | 118  | Og   |

# RSA

RSA算法的具体描述如下：

（1）任意选取两个不同的大素数p和q计算乘积

![img](images\f0dac18152076624d87832b62709895c.svg)

（2）任意选取一个大整数e，满足

![img](images\c33d8c66364a636b051d82f0ee202a36.svg)

 ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用）；

（3）确定的解密钥d，满足

![img](images\da8649c0078a0a842779394d64011776.svg)

 ，即

![img](images\4dee3f4df52a81983db0e3c619f96058.svg)

 是一个任意的整数；所以，若知道e和

![img](images\679e809a0d964785d0aa4cfcb4218742.svg)

，则很容易计算出d；

（4）公开整数n和e，秘密保存d；

（5）将明文m（m<n是一个整数）加密成密文c，加密算法为

![img](images\5947116555169dc6fe9e3f5cdf347706.svg)

（6）将密文c解密为明文m，解密算法为 

![img](images\1a8b337167e4d4b2c23855d88ec4c67f.svg)

然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密 。

## 求d、m、c

工具：`RSA-Tool 2 by tE!`，输入p、q和e来计算d，其中e是16进制数。需要注意的是根据p、q的值来选择Number Base采用的进制数。

Python脚本：RSA.py

`long_to_bytes`来把数字的明文转为字符。

```python
m = 2077392566271985655506271571624317
print(long_to_bytes(m)) #b'flag{b4by_R5A}'
```

## 分解d

工具：`RSA-Tool 2 by tE!`，输入d，点击factor N。

## 求解明文

若N为大数，使用工具分解N将比较困难，存在以下几种解法：

1. E相同，N不同，则可以求解两个N的最大公约数，得到P，进而得到Q。

   ```python
   from Crypto.Util.number import long_to_bytes
   import gmpy2
   
   n1 = 23686563925537577753047229040754282953352221724154495390687358877775380147605152455537988563490716943872517593212858326146811511103311865753018329109314623702207073882884251372553225986112006827111351501044972239272200616871716325265416115038890805114829315111950319183189591283821793237999044427887934536835813526748759612963103377803089900662509399569819785571492828112437312659229879806168758843603248823629821851053775458651933952183988482163950039248487270453888288427540305542824179951734412044985364866532124803746008139763081886781361488304666575456680411806505094963425401175510416864929601220556158569443747
   n2 = 22257605320525584078180889073523223973924192984353847137164605186956629675938929585386392327672065524338176402496414014083816446508860530887742583338880317478862512306633061601510404960095143941320847160562050524072860211772522478494742213643890027443992183362678970426046765630946644339093149139143388752794932806956589884503569175226850419271095336798456238899009883100793515744579945854481430194879360765346236418019384644095257242811629393164402498261066077339304875212250897918420427814000142751282805980632089867108525335488018940091698609890995252413007073725850396076272027183422297684667565712022199054289711
   
   p = gmpy2.gcd(n1, n2)
   q = n1 // p
   
   print(p)
   print(q)
   ```

2. E不同，N相同，即使用相同的模数N，不同的密钥，加密同一明文。

   ```python
   import gmpy2
   from Crypto.Util.number import long_to_bytes
   
   n = 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571
   e1 = 797
   e2 = 521
   c1 = 11157593264920825445770016357141996124368529899750745256684450189070288181107423044846165593218013465053839661401595417236657920874113839974471883493099846397002721270590059414981101686668721548330630468951353910564696445509556956955232059386625725883038103399028010566732074011325543650672982884236951904410141077728929261477083689095161596979213961494716637502980358298944316636829309169794324394742285175377601826473276006795072518510850734941703194417926566446980262512429590253643561098275852970461913026108090608491507300365391639081555316166526932233787566053827355349022396563769697278239577184503627244170930
   c2 = 6699274351853330023117840396450375948797682409595670560999898826038378040157859939888021861338431350172193961054314487476965030228381372659733197551597730394275360811462401853988404006922710039053586471244376282019487691307865741621991977539073601368892834227191286663809236586729196876277005838495318639365575638989137572792843310915220039476722684554553337116930323671829220528562573169295901496437858327730504992799753724465760161805820723578087668737581704682158991028502143744445435775458296907671407184921683317371216729214056381292474141668027801600327187443375858394577015394108813273774641427184411887546849
   
   s = gmpy2.gcdext(e1, e2)  # 扩展欧几里得算法
   m1 = gmpy2.powmod(c1, s[1], n)
   m2 = gmpy2.powmod(c2, s[2], n)
   m = (m1*m2) % n
   print(long_to_bytes(m))
   ```

3. E过小，N过大，低加密指数攻击，导致明文E次方仍然小于N，C=M^E。

   ```python
   import gmpy2
   from Crypto.Util.number import long_to_bytes
   
   e = 3
   n = 18970053728616609366458286067731288749022264959158403758357985915393383117963693827568809925770679353765624810804904382278845526498981422346319417938434861558291366738542079165169736232558687821709937346503480756281489775859439254614472425017554051177725143068122185961552670646275229009531528678548251873421076691650827507829859299300272683223959267661288601619845954466365134077547699819734465321345758416957265682175864227273506250707311775797983409090702086309946790711995796789417222274776215167450093735639202974148778183667502150202265175471213833685988445568819612085268917780718945472573765365588163945754761
   c = 150409620528139732054476072280993764527079006992643377862720337847060335153837950368208902491767027770946661
   
   m = gmpy2.iroot(c, e) # c开e次根
   print(long_to_bytes(m[0]))
   ```

4. 当E过大时，低解密指数攻击。

   使用RsaCtfTool.py，安装在Kali中， 目录：/root/Tools/RsaCtfTool

   ```shell
   python3  RsaCtfTool.py --createpub -n N -e E --attack wiener > test.pem
   #删除test.pem中的一些非密钥字段
   
   python3 RsaCtfTool.py --publickey test.pem --private > test.key
   #删除test.key中的一些非密钥字段
   
    python3 RsaCtfTool.py --key test.key --dumpkey 
    #求得P和Q
   ```

5. 当p、q的取值差异过大或过于相近的时候，求解方法同4。

## 密文（文件）

```python
import gmpy2
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

n = 0x39549554ca3c820c3591b3f367ea171677525811bc54b26083c81c22717d2cc2b109dcaa5572b7942236823c6f4521ad97ac2587b170c76691be7bff83982a98644fca24e421483b013808f134dfa3587bd38c87c7b7b8da7655c784b05e42d789bceec0786261def6a3062706fdc236fd780eecefe8761de86d0f964e51e1c011
e = 65537

p = 97
q = 106249972159566919549855203174197828387397831115262336234662051342543151219702510584956705611794290291345944183845955839244363030579896461607496959399297130227066841321473005074379950936513608503266587950271044991876848389878395867601515004796212227929894460104645781488319246866661398816686697306692491058609
phi = (p-1)*(q-1)
d = int(gmpy2.invert(e, phi))

privatekey = RSA.construct((n, e, d, p, q))
rsa = PKCS1_OAEP.new(privatekey)
m = rsa.decrypt(open("E:\\my_ctf_learning\\CTF题目\\Crypto\ctf.show_easyrsa8\\easyrsa8\\flag.enc", "rb").read())
print(m)
```

例子见：ctf.show_easyrsa8

